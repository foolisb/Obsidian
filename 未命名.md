要理解 `arch_initcall` 和 **Early Boot**，我们需要把 Linux 内核的启动想象成一场**由内而外、分阶段递进**的“开学典礼”。

内核初始化是一个极其严密的流程，为了保证依赖关系不乱，内核将初始化过程划分为多个**优先级等级（Initcalls）**。

---

### 1. 什么是 Early Boot（早期启动）？

**Early Boot** 指的是从 Bootloader（如 U-Boot）跳转到内核入口，直到内核能够正常管理内存和调度之前的“黑暗时代”。

在这个阶段，CPU 刚跳入 C 语言环境，系统处于**极其脆弱**的状态：

- **没有虚拟内存**：还在处理 MMU 映射。
    
- **没有标准输出**：串口驱动还没加载，打印信息（`printk`）全靠 `early_printk` 这种硬编码的小工具。
    
- **没有中断**：CPU 屏蔽了所有中断。
    
- **关键任务**：解析设备树（DTB）、初始化页表、识别 CPU 型号。
    

---

### 2. 什么是 `arch_initcall`？

在 Early Boot 结束，进入 `start_kernel()` 后，内核开始执行一系列有序的初始化函数。为了管理成千上万个驱动和子系统，内核定义了 **8 个主要优先级**。

`arch_initcall` 是其中之一（等级为 **3**）。

|**宏定义**|**等级**|**用途**|
|---|---|---|
|`pure_initcall`|0|最基础的内核定义，不依赖任何东西。|
|`core_initcall`|1|核心子系统（如调度器、关键总线）。|
|`postcore_initcall`|2|核心之后的清理/准备。|
|**`arch_initcall`**|**3**|**特定架构（ARM/x86）相关的初始化，如枚举设备树节点。**|
|`subsys_initcall`|4|通用子系统（网络、文件系统）。|
|`fs_initcall`|5|文件系统挂载相关的初始化。|
|`device_initcall`|6|**普通驱动（你的 platform_driver）通常在这里注册。**|
|`late_initcall`|7|最后扫尾，如清理临时内存。|

**核心机制：** 开发者只需在函数末尾写上 `arch_initcall(my_func);`，链接器就会把这个函数的指针放到内核镜像里一个特殊的段（Section）中。启动时，内核会按等级顺序遍历这些段，依次执行函数。

---

### 3. 完整的内核初始化流程图 (Linux 6.x)

#### 流程分解：

1. **汇编阶段 (`head.S`)**：
    
    - 检查 CPU ID，初始化简单页表。
        
2. **`start_kernel()` (内核大管家)**：
    
    - 位于 `init/main.c`，这是内核的心脏。
        
    - 初始化内存管理（`mm_init`）、中断向量表、调度器。
        
3. **`rest_init()`**：
    
    - 创建一个名为 `kernel_init` 的内核线程（PID 1）。
        
4. **`do_initcalls()` (重点)**：
    
    - 这是 `kernel_init` 线程执行的关键步骤。
        
    - 它会按照上表 0 到 7 的顺序执行所有宏定义的函数。
        
    - **在 Level 3 (`arch_initcall`)**：内核扫描设备树，根据 `compatible` 属性，把 DTS 里的节点“幻化”成一个个 `platform_device` 对象。
        
    - **在 Level 6 (`device_initcall`)**：你的 `platform_driver` 注册进总线，发现 Level 3 已经准备好的 `device`，双方 `probe` 成功。
        
5. **挂载根文件系统 & 执行 `init`**：
    
    - 内核功成身退，把控制权交给用户态的第一个程序（如 `systemd` 或 `sh`）。
        

---

### 4. 总结：为什么要分这么多层？

这是一种**依赖管理策略**：

- 如果没有 `arch_initcall` 预先解析出设备树里的硬件信息，后续 `device_initcall` 里的驱动就找不到硬件资源。
    
- 如果没有 `core_initcall` 初始化内存，后续所有的初始化都无法申请内存空间。
    

**你想亲自看看你的内核镜像里到底排了多少个 initcall 吗？** 你可以尝试在启动参数里加入 `initcall_debug`，内核启动时会详细打印出每一个函数的执行顺序和耗时。

要我教你如何分析这些 `initcall_debug` 日志吗？


![[企业微信截图_17721570866860.png]]
----
#### 电磁干扰导致比特翻转
> **电磁干扰 ：** 电磁干扰(Electromagnetiv Interference, EMI)是干扰
> 电缆信号并降低信号完好性的电子噪音，EMI通常由电磁辐射发生源产生。

>**内存与CPU传输数据的过程中容易受到电磁干扰导致发送比特翻转，使原来是0的数据
>变成1，原来是1的数据变成0
>![[电磁干扰.png]]

> **比特翻转位于不重要的数据最多导致软件闪退或报错
>![[Pasted image 20220717181937.png]]

>**比特翻转位于重要的驱动或系统数据会导致死机蓝屏
>![[Pasted image 20220717184500.png]]

>**如果死机发生在pc上只需要重启即可，但是对于服务器来说一次死机的成本太高，需要用稳定性更高的ecc内存保证系统的稳定运行，这种内存能够主动发现数据传输过程的错误并纠正
>![[Pasted image 20220717185943.png]]

----
#### ECC纠错原理
>**一般来说实现数据纠错最简单的方法就是同时传输三组一样的数据
>![[Pasted image 20220717194903.png]]

>**通过对比其他两组数据就能定位错误数据的位置并纠正
>![[Pasted image 20220717195009.png]]
>![[Pasted image 20220717195147.png]]

>**如果两组数据在同一个位置发生比特翻转，那么在纠错的过程中就会将错误
>的数据当成正确的
>![[Pasted image 20220717195303.png]]
>![[Pasted image 20220717195416.png]]

>**上面的问题还不算大问题，真正的问题在于这种方式过于浪费带宽，数据总量中有2/3是纠错码，只有1/3的数据是有效数据
>![[Pasted image 20220717195608.png]]

----
#### 奇偶校验
>**为了解决这个问题，人们提出了奇偶校验。在计算机中使用的是二进制数据，我们可以在数据的开头增加一位纠错码
>![[Pasted image 20220717195801.png]]
>![[Pasted image 20220717195823.png]]

>**输出数据中1的个数，如果1的个数为偶数，那么纠错码填充为0
>![[Pasted image 20220717200851.png]]
>如果1的个数为奇数纠错码填充为1，将数据中的1的个数填补为偶数
>![[Pasted image 20220717201005.png]]

>![[Pasted image 20220717201245.png]]
>**接收方收到数据后，如果1的个数为偶数，数据没有错误
>![[Pasted image 20220717201302.png]]
>如果1的数据为奇数，说明数据有错误，需要重新传输
>![[Pasted image 20220717201547.png]]

>**那么如果纠错码本身发生的比特翻转？
>![[Pasted image 20220717202548.png]]


>**其实并没有区别，纠错码发生比特翻转后1的总个数变为奇数，接收方还是会认为数据发生了错误，只不过纠错码发生比特翻转并不影响原始数据
>![[Pasted image 20220717202700.png]]
>
>>奇偶校验不是用一个数去校验其他数据，而是用一个数据改变整组数据的奇偶性，纠错码本身就处于改组数据中

>**但是奇偶校验只能单纯的判断数据是否有错，并不能定位错误数据的位置，发现错误后需要等待发送方重传数据，这样会造成一定的延迟
>![[Pasted image 20220717204033.png]]
>而且只依靠数据的奇偶性无法处理两位错误数据，当数据中有两位数据发生比特翻转的时候，1的总个数还是偶数
>![[Pasted image 20220717204103.png]]

#### 汉明码
>**为了解决以上两个问题，美国图灵奖获得者理查德汉明在奇偶检验的基础上提出了汉明码，也就是目前大多数ecc内存使用的纠错码，它能用很少的纠错码对大量的数据就行错误查找和纠正
>***有意思的是他和香农曾经共用过办公室，香农研究信息论，他研究编码理论***
>![[Pasted image 20220717204802.png]]

>**这里可以通过一个简单的例子来了解汉明码的实现原理
>有一只狗在左边的三个方框中，已知狗在<font color=blue size=5>蓝色</font>方框中也在<font color=green size=5>绿色</font>方框中，但是不在<font color=red size=5>红色</font>方框中，那么狗在哪个区域？
>![[Pasted image 20220717210029.png]]




>**答案是
>![[Pasted image 20220717210942.png]]
>**首先通过奇偶检验确定数据是否发生错误，在根据一定的交集和排除就能确定错误数据的位置，这就是汉明码的核心原理
>![[Pasted image 20220717211738.png]]

>**下面是一组16bit的数据，为了方便演示将其排列成4x4的数据矩阵
>![[Pasted image 20220717212240.png]]
>![[Pasted image 20220717212259.png]]
>那么为了定位数据的错位，接下来就像刚才找那只狗一样需要有规律的将数据分成几组，并且它们之间要有一定的交集，那么我们应该怎样进行分组？


>**二分法来定位错误数据，将数据分成两半， 如果错误不在这一半就在另一半
>
>将2号位用作检验位不在存放原始数据，而是对右半边的数据进行奇偶检验
>![[Pasted image 20220717220509.png]]
>因为右半边1的个数为偶数，所以保持校验位为0
>![[Pasted image 20220717221321.png]]
>假设在传输的过程中有一位数据发生比特翻转，接收方如果发现右半边1的个数为奇数，说明错误在右边
>![[Pasted image 20220717221410.png]]
>如果右半边1的个数为偶数，说明错误的位置在左半边
>![[Pasted image 20220717221723.png]]

>**按照这个思路往下，还需要一个纠错码将一半的数据再进行对半分组，进一步缩小范围，这里将1号位作为纠错码也不存放原始数据，对2、4列数据进行奇偶校验
>![[Pasted image 20220717222032.png]]
>2、4列中1的个数为奇数，所以将1号纠错码填充为1，让2、4列中1的个数为偶数
>![[Pasted image 20220717222403.png]]
>还是假设在传输的过程中有一位数据发生比特翻转，接收方如果发现2、4列中1的个数为奇数，说明错误在2、4列
>![[Pasted image 20220717222807.png]]
>如果2、4列中1的个数为偶数，那么错误在1、3列
>![[Pasted image 20220717223025.png]]

>**根据这两个区域的奇偶检验结果就能确定错误数据所在的列
>
>依然假设数据块内有一个错误，如果1号区域和2号区域都通过奇偶校验没有发现错误，那么说明错误在第1列
>![[Pasted image 20220717223245.png]]
>如果1号区域和2号区域都没通过奇偶校验，那么说明错误在第4列
>![[Pasted image 20220717223758.png]]
>如果1号区域通过奇偶检验，而2号区域没有通过奇偶校验，那么说明错误在第3列
>![[Pasted image 20220717223915.png]]
>反过来如果1号区域没通过奇偶检验，而2号区域通过，说明错误在第2列
>![[Pasted image 20220717224110.png]]

>**当确定错误所在的列以后，就可以用同样的方法确定错误所在的行
>![[Pasted image 20220717225742.png]]
>可以用4号纠错码检测2、4行
>![[Pasted image 20220717225843.png]]
>用8号纠错码检测3、4行
>![[Pasted image 20220717230000.png]]
>通过一定的排除和交集就能确定错误所在的行，结合1、2区域判断出来的列就能精确确定错误数据的位置
>![[Pasted image 20220717230221.png]]
>因为二进制数据只能是1或0，一旦找到错误数据所在的位置重新翻转回来就可以实现纠正
>![[Pasted image 20220717230542.png]]
----
#### 电磁干扰导致比特翻转
> **电磁干扰 ：** 电磁干扰(Electromagnetiv Interference, EMI)是干扰
> 电缆信号并降低信号完好性的电子噪音，EMI通常由电磁辐射发生源产生。

>**内存与CPU传输数据的过程中容易受到电磁干扰导致发送比特翻转，使原来是0的数据
>变成1，原来是1的数据变成0
>![[电磁干扰.png]]

> **比特翻转位于不重要的数据最多导致软件闪退或报错
>![[Pasted image 20220717181937.png]]

>**比特翻转位于重要的驱动或系统数据会导致死机蓝屏
>![[Pasted image 20220717184500.png]]

>**如果死机发生在pc上只需要重启即可，但是对于服务器来说一次死机的成本太高，需要用稳定性更高的ecc内存保证系统的稳定运行，这种内存能够主动发现数据传输过程的错误并纠正
>![[Pasted image 20220717185943.png]]

----
#### ECC纠错原理
>**一般来说实现数据纠错最简单的方法就是同时传输三组一样的数据
>![[Pasted image 20220717194903.png]]

>**通过对比其他两组数据就能定位错误数据的位置并纠正
>![[Pasted image 20220717195009.png]]
>![[Pasted image 20220717195147.png]]

>**如果两组数据在同一个位置发生比特翻转，那么在纠错的过程中就会将错误
>的数据当成正确的
>![[Pasted image 20220717195303.png]]
>![[Pasted image 20220717195416.png]]

>**上面的问题还不算大问题，真正的问题在于这种方式过于浪费带宽，数据总量中有2/3是纠错码，只有1/3的数据是有效数据
>![[Pasted image 20220717195608.png]]

----
#### 奇偶校验
>**为了解决这个问题，人们提出了奇偶校验。在计算机中使用的是二进制数据，我们可以在数据的开头增加一位纠错码
>![[Pasted image 20220717195801.png]]
>![[Pasted image 20220717195823.png]]

>**输出数据中1的个数，如果1的个数为偶数，那么纠错码填充为0
>![[Pasted image 20220717200851.png]]
>如果1的个数为奇数纠错码填充为1，将数据中的1的个数填补为偶数
>![[Pasted image 20220717201005.png]]

>![[Pasted image 20220717201245.png]]
>**接收方收到数据后，如果1的个数为偶数，数据没有错误
>![[Pasted image 20220717201302.png]]
>如果1的数据为奇数，说明数据有错误，需要重新传输
>![[Pasted image 20220717201547.png]]

>**那么如果纠错码本身发生的比特翻转？
>![[Pasted image 20220717202548.png]]


>**其实并没有区别，纠错码发生比特翻转后1的总个数变为奇数，接收方还是会认为数据发生了错误，只不过纠错码发生比特翻转并不影响原始数据
>![[Pasted image 20220717202700.png]]
>
>>奇偶校验不是用一个数去校验其他数据，而是用一个数据改变整组数据的奇偶性，纠错码本身就处于改组数据中

>**但是奇偶校验只能单纯的判断数据是否有错，并不能定位错误数据的位置，发现错误后需要等待发送方重传数据，这样会造成一定的延迟
>![[Pasted image 20220717204033.png]]
>而且只依靠数据的奇偶性无法处理两位错误数据，当数据中有两位数据发生比特翻转的时候，1的总个数还是偶数
>![[Pasted image 20220717204103.png]]

#### 汉明码
>**为了解决以上两个问题，美国图灵奖获得者理查德汉明在奇偶检验的基础上提出了汉明码，也就是目前大多数ecc内存使用的纠错码，它能用很少的纠错码对大量的数据就行错误查找和纠正
>***有意思的是他和香农曾经共用过办公室，香农研究信息论，他研究编码理论***
>![[Pasted image 20220717204802.png]]

>**这里可以通过一个简单的例子来了解汉明码的实现原理
>有一只狗在左边的三个方框中，已知狗在<font color=blue size=5>蓝色</font>方框中也在<font color=green size=5>绿色</font>方框中，但是不在<font color=red size=5>红色</font>方框中，那么狗在哪个区域？
>![[Pasted image 20220717210029.png]]




>**答案是
>![[Pasted image 20220717210942.png]]
>**首先通过奇偶检验确定数据是否发生错误，在根据一定的交集和排除就能确定错误数据的位置，这就是汉明码的核心原理
>![[Pasted image 20220717211738.png]]

>**下面是一组16bit的数据，为了方便演示将其排列成4x4的数据矩阵
>![[Pasted image 20220717212240.png]]
>![[Pasted image 20220717212259.png]]
>那么为了定位数据的错位，接下来就像刚才找那只狗一样需要有规律的将数据分成几组，并且它们之间要有一定的交集，那么我们应该怎样进行分组？


>**二分法来定位错误数据，将数据分成两半， 如果错误不在这一半就在另一半
>
>将2号位用作检验位不在存放原始数据，而是对右半边的数据进行奇偶检验
>![[Pasted image 20220717220509.png]]
>因为右半边1的个数为偶数，所以保持校验位为0
>![[Pasted image 20220717221321.png]]
>假设在传输的过程中有一位数据发生比特翻转，接收方如果发现右半边1的个数为奇数，说明错误在右边
>![[Pasted image 20220717221410.png]]
>如果右半边1的个数为偶数，说明错误的位置在左半边
>![[Pasted image 20220717221723.png]]

>**按照这个思路往下，还需要一个纠错码将一半的数据再进行对半分组，进一步缩小范围，这里将1号位作为纠错码也不存放原始数据，对2、4列数据进行奇偶校验
>![[Pasted image 20220717222032.png]]
>2、4列中1的个数为奇数，所以将1号纠错码填充为1，让2、4列中1的个数为偶数
>![[Pasted image 20220717222403.png]]
>还是假设在传输的过程中有一位数据发生比特翻转，接收方如果发现2、4列中1的个数为奇数，说明错误在2、4列
>![[Pasted image 20220717222807.png]]
>如果2、4列中1的个数为偶数，那么错误在1、3列
>![[Pasted image 20220717223025.png]]

>**根据这两个区域的奇偶检验结果就能确定错误数据所在的列
>
>依然假设数据块内有一个错误，如果1号区域和2号区域都通过奇偶校验没有发现错误，那么说明错误在第1列
>![[Pasted image 20220717223245.png]]
>如果1号区域和2号区域都没通过奇偶校验，那么说明错误在第4列
>![[Pasted image 20220717223758.png]]
>如果1号区域通过奇偶检验，而2号区域没有通过奇偶校验，那么说明错误在第3列
>![[Pasted image 20220717223915.png]]
>反过来如果1号区域没通过奇偶检验，而2号区域通过，说明错误在第2列
>![[Pasted image 20220717224110.png]]

>**当确定错误所在的列以后，就可以用同样的方法确定错误所在的行
>![[Pasted image 20220717225742.png]]
>可以用4号纠错码检测2、4行
>![[Pasted image 20220717225843.png]]
>用8号纠错码检测3、4行
>![[Pasted image 20220717230000.png]]
>通过一定的排除和交集就能确定错误所在的行，结合1、2区域判断出来的列就能精确确定错误数据的位置
>![[Pasted image 20220717230221.png]]
>因为二进制数据只能是1或0，一旦找到错误数据所在的位置重新翻转回来就可以实现纠正
>![[Pasted image 20220717230542.png]]

>![[Pasted image 20220717231049.png]]
>
>**之前的校验都假设有一个错误作为前提，如果我们不知道盘面是否有错误，而且1、2、3、4都通过了奇偶校验，那么0号位的数据将不被纳入保护范围，无论是0还是1都不影响4个区域的检验结果
>
>
>![[Pasted image 20220717231627.png]]
>解决的方法就是0号位也作为纠错码，对整个盘面的数据进行奇偶检验，这样既能知道盘面是否出错，也能规避0号位不被保护的问题

>![[Pasted image 20220717232402.png]]

>**如果盘面中出现了两个错误数据
>![[Pasted image 20220717232853.png]]
>根据区域的检验结果可以定位错误位置在11号位吗，但是整个盘面有8个1是偶数，说明盘面通过了奇偶校验没有错误，这时盘面的结论和区域的结论发生了冲突，说明有两个错误，虽然没有办法确定两个错误的位置，但至少知道数据有错重新传输数据即可
>![[Pasted image 20220717233359.png]]
>
>如果同时出现3个错误，汉明码就无法解决，这个时候就不能一直依靠纠错码，而是考虑如何降低出现多个错误的概率。纠错码的意义在于用尽可能少的数据，纠正不可避免的错误
>![[Pasted image 20220717234105.png]]


>**现在将数据重新横向展开
>![[Pasted image 20220717234540.png]]
>可以发现除了0号位，汉明码的位置正好位于2的0,1,2,3次方的位置，这是汉明码包含二分法原理的原因
>![[Pasted image 20220717234606.png]]
>如果后期想要传输更多的数据，只要在数据2的n次方位置放置一位纠错码就可以实现对更大块数据的支持。数据块越大，纠错码的占比越小，同时数据块中出现多个错误的概率也就越大
>![[Pasted image 20220717234656.png]]

----
#### ecc内存
>**常用的ecc内存一个块的大小为72bit
>![[Pasted image 20220717235320.png]]
>其中64bit为原始数据，另外8bit是这64bit的纠错码
>![[Pasted image 20220717235416.png]]
>因为汉明码需要额外的数据存放纠错码，所以普通8G内存只需要8颗1G的颗粒，而ecc内存需要9颗1G颗粒来实现8G可用容量
>![[Pasted image 20220717235553.png]]

>**汉明码的优势不在于用少量的纠错码对大量的数据进行纠错
>![[Pasted image 20220717235858.png]]
>因为目前已经有更先进的LDPC纠错码，由香农的学生mit教授罗比特在他的博士论文中提出，==5G上用的就是这个==广泛运用于SATA和NVME硬盘的纠错上，它能查找并解决多位比特翻转
>![[Pasted image 20220717235919.png]]

>**但是汉明码依旧在内存上发挥巨大作用，主要原因是汉明码的硬件实现很简单
>首先实现一个4x4的数据矩阵
>![[Pasted image 20220718001327.png]]
>把原先十进制的位置下标换成二进制表示
>![[Pasted image 20220718001341.png]]
>按照原来的方法对矩阵进行奇偶校验，但是这次要记录奇偶校验的结果，通过的区域记为0，没有通过记为1
>![[Pasted image 20220718001447.png]]
>![[Pasted image 20220718001648.png]]
>将区域的校验结果按照区域号从高到低排列，结果刚好对应错误数据的位置，这说明位置信息和校验结果之间有一些联系
>![[Pasted image 20220718001718.png]]


>**下面可以仔细观察一下位置下标的二进制数
>![[Pasted image 20220718002100.png]]
>在1号区域中所有二进制数的第一位，都是1，而1号区域以外的二进制数的第一位都是0
>![[Pasted image 20220718002247.png]]
>同理可得2号区域中的所有二进制数的第二位都是1，3号区域和4号区域类似
>![[Pasted image 20220718002419.png]]

>**根据这个性质，将矩阵中所有1的位置数取出来，从上到下排列好
>![[Pasted image 20220718002620.png]]
>观察它们的第一位，发现有两个1，刚好是1号区域中的两个1，这就相当于这一列数表明1号区域有两个1
>![[Pasted image 20220718002836.png]]
>按照这个思路，第二列数表明2号区域有4个1，3好区域和4号区域类似
>![[Pasted image 20220718003252.png]]

>**接下来将这四列数进行异或运算
>![[Pasted image 20220718003612.png]]
>因为四个区域中1的个数都是偶数，所以异或的结果为0000
>![[Pasted image 20220718003841.png]]